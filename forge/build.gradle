plugins {
    id 'com.gradleup.shadow'
}

archivesBaseName = "${mod_id}-forge"
version = "${rootProject.mod_version}_mc${rootProject.forge_supported_versions}"

architectury {
    platformSetupLoomIde()
    forge()
}

loom {
    forge {
        mixinConfigs = [
                "elytra_physics.mixins.json"
        ]
    }
}

configurations {
    common {
        canBeResolved = true
        canBeConsumed = false
    }
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    developmentForge.extendsFrom common

    // Files in this configuration will be bundled into your mod using the Shadow plugin.
    // Don't use the `shadow` configuration from the plugin itself as it's meant for excluding files.
    shadowBundle {
        canBeResolved = true
        canBeConsumed = false
    }

}

repositories {
    // Put repositories for dependencies here
    // ForgeGradle automatically adds the Forge maven and Maven Central for you

    // If you have mod jar dependencies in ./libs, you can declare them as a repository like so.
    // See https://docs.gradle.org/current/userguide/declaring_repositories.html#sub:flat_dir_resolver
    // flatDir {
    //     dir 'libs'
    // }
}

// Include resources generated by data generators.
//sourceSets.main.resources { srcDir 'src/generated/resources' }

dependencies {
    // forge mod loader
    forge "net.minecraftforge:forge:${rootProject.minecraft_version}-${rootProject.forge_version}"

    // mixin extras
    compileOnly(annotationProcessor("io.github.llamalad7:mixinextras-common:0.4.1"))
    implementation(include("io.github.llamalad7:mixinextras-forge:0.4.1"))

    // common files
    common(project(path: ':common', configuration: 'namedElements')) { transitive false }
    shadowBundle project(path: ':common', configuration: 'transformProductionForge')
}

processResources {
//    inputs.property 'version', project.version
//
//    filesMatching('META-INF/mods.toml') {
//        expand version: project.version
//    }
    var replaceProperties = [
            mod_id: rootProject.mod_id, mod_name: rootProject.mod_name, mod_license: rootProject.mod_license, mod_version: rootProject.mod_version,
            mod_authors: rootProject.mod_authors, mod_description: rootProject.mod_description,
    ]

    inputs.properties replaceProperties

    filesMatching(['META-INF/mods.toml', 'pack.mcmeta']) {
        expand replaceProperties + [project: project]
    }
}

shadowJar {
    configurations = [project.configurations.shadowBundle]
    archiveClassifier = 'dev-shadow'
}

remapJar {
    inputFile.set shadowJar.archiveFile

}


// Example for how to get properties into the manifest for reading at runtime.
//tasks.named('jar', Jar).configure {
//    manifest {
//        attributes([
//                'Specification-Title'     : mod_id,
//                'Specification-Vendor'    : mod_authors,
//                'Specification-Version'   : '1', // We are version 1 of ourselves
//                'Implementation-Title'    : project.name,
//                'Implementation-Version'  : project.jar.archiveVersion,
//                'Implementation-Vendor'   : mod_authors,
//                'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
//                "TweakClass"              : "org.spongepowered.asm.launch.MixinTweaker",
//                "TweakOrder"              : 0,
//                'MixinConfigs'            : "${mod_id}.mixins.json"
//        ])
//    }
//
//    // This is the preferred method to reobfuscate your jar file
//    finalizedBy 'reobfJar'
//}

// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing:
// tasks.named('publish').configure {
//     dependsOn 'reobfJar'
// }


//tasks.withType(JavaCompile).configureEach {
//    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
//}
